# Deep Learn Git

 * `git hash-object <filename>` — получение хеша файла, под которым он будет храниться.
 * `git show <hash-id>` — получение информации по хешу.
 * `git cat-file -t <hash-id>` — определение типа по хешу (blob, commit, tree...).
 * `git cat-file blob <hash-id>` — получение содержимого blob'а по хешу.
 * `git cat-file -t HEAD` — определение (проверка) типа объекта, на который ссылается `HEAD`.
 * `git cat-file commit HEAD` — получение хеша дерева, содержащееся в коммите, на который указывает `HEAD`.
 * `git ls-tree <hash-id>` — просмотр дерева для заданного дерева или коммита.
 * `git ls-tree HEAD` — просмотр дерева для заданного (дерева или) коммита, на который ссылается `HEAD`.
 * `git ls-files --stage` — показывает объекты, на который ссылается индекс.
 * `git rev-parse HEAD` — декодирует `HEAD` в хеш коммита, на который он ссылается.
 * `git write-tree` — записывает содержимое индекса в (новое) дерево для дальнейшего создания коммита; выводит идентификатор этого дерева.
 * `echo 'Commit message' | git commit-tree <tree-hash-id>` — создаёт напрямую новый объект коммита, используя заданное хешем дерево; ключ `-p` может задавать родительский объект для коммита; выводит хеш нового коммита.
 * `echo <commit-hash-id> > .git/refs/heads/master` — регистрирует указанный коммит в качестве головного для текущей (master) ветки.
 * `git update-ref refs/heads/master <commit-hash-id>` — более безопасный способ регистрации коммита в качестве головного.
 * `git symbolic-ref HEAD refs/heads/master` — создание символической ссылки `HEAD` на ветку master (связывает текущее дерево с веткой master).
 * `git reset --hard <commit-hash-id>` — перемещение "головы" дерева на указанный хешем коммит; опция `--hard` удаляет все изменения в рабочем дереве (все изменённые файлы: зарегистрированные и нет); изменяет `HEAD`, чтобы он указывал на заданную версию дерева.
 * `git checkout <commit-hash-id>` — переход к указанному коммиту с сохранением текущих изменений в рабочем дереве.
 * `git checkout -f <commit-hash-id>` — действует подобно `git reset --hard`, но без изменения `HEAD`.
 * `git show-branch` — детальная информация о ветках в репозитории.
 * `git reset --mixed [<commit-hash-id>]` — возвращает индекс и `HEAD` к состоянию выбранного коммита (`--mixed` — опция по умолчанию).
 * `git reset --soft [<commit-hash-id>]` — меняет исключительно `HEAD`, не затрагивая индекс.
 * `git reset --hard [<commit-hash-id>]` — уничтожает все изменения, сделанные в рабочем дереве таким образом, что рабочие файлы станут соответствовать содержимому `HEAD`, например, `git reset --hard HEAD~3`.
 * `git reset --hard HEAD@{1}` — восстановить из reflog перед изменением.
 * `git reset --soft HEAD^` — сохраняет резервную копию `HEAD` в родительской; эффективно игнорируя последний коммит.
 * `git update-ref HEAD HEAD^` — эквивалентно предыдущей команде, но вручную.
 * `git reset --hard HEAD@{1}` — восстановить из reflog перед изменением.
 * `git stash` — сохраняет текущие изменения без изменения индекса, чтобы затем их можно было вернуть.
 * `git stash list` — список сохранённых изменений.
 * `git log stash@{<number>}` — когда сделано изменение?
 * `git show stash@{<number>}` — что было сделано?
 * `git checkout -b <temporary-branch-name> stash@{<number>}` — посмотреть сохранённое дерево.
 * `git stash clear` — очищает список сохранённых изменений (лучше оставлять).
 * `git reflog expire --expire=30.days refs/stash` — очищать reflog по истечению 30 дней.
 * `git commit --amend` — позволяет исправить последний коммит.
 * `git ` — ...

# Names
 * `branchname` — имя ветки; псевдоним самого недавнего коммита в эту ветку; равносильно использованию слова `HEAD`, когда данная ветка уже выбрана (checked out); меняется каждый раз при добавлении коммита в ветку.
 * `tagname` — псевдоним коммита, идентичный имени ветки; никогда не меняется при добавлении новых коммитов и может иметь описание подобно коммиту.
 * `HEAD` — псевоним текущего коммита в данную ветку; при выборе определённого коммита ссылается именно на него, а не на имя текущей ветки (detached head — отделённая голова).
 * `<hash-id>` — к коммиту всегда можно обратиться по его 40-символьному хешу sha-1; обычно это происходит при копировании/вставке коммитов, так как обычно имеются другие более удобные способы.
 * `<clipped-hash-id>` — необходимо использовать только ту начальную часть хеша, которая однозначно определяет коммит; обычно это 6-7 первых символов.
 * `name^` — ссылка на родителя коммита; если у коммита более одного предка, то берётся первый из них.
 * `name^<number>` — ссылка на родителя коммита для случая, когда у коммита более одного предка: берётся под номером `<number>`.
 * `name^^` — можно последоавтельно добавлять символ каретки `^`,  определяет ссылку на родителей кратным образом (родитель родителя...); то есть предков в каком-либо поколении.
 * `name~<number>` — ссылка на предков в `n`-ом поколении может быть задана с помощью тильды `~`; эквивалентно `name^^^^...`, где `^` повторяется `<number>` раз; обычно используется с командой `git rebase -i`.
 * `name:path` — обращение к определённому файлу `path` внутри дерева коммита, заданного именем/хешем `name`; может быть полезно для команды `git show` или для сравнения двух версий файла между коммитами: `git diff HEAD^1:<filename> HEAD^2:<filename>`.
 * `name^{tree}` — обращение не к самому коммиту, а к содержащему его дереву.
 * `name1..name2` — задаёт диапазон коммитов (полезно с командами типа `git log ...`); адресует все предшествующие коммиты начиная с `name2` и до `name1` (не включая его); если какое-то из имён опускается, вместо него используется `HEAD`.
 * `name1...name2` — для команд типа `git log ...` обозначает все коммиты, на которые ссылаются либо `name1`, либо `name2`, но не оба сразу; результат — список уникальных коммитов в обеих ветках; для команд наподобие `git diff ...` диапазон выражается коммитами между `name2` и общим предком коммитов `name1` и `name2` (в отличие от `git log ...` не показываются изменения, сделанные в коммите `name1`).
 * `master..` — эквивалентно `master..HEAD`; удобно при разборе изменений, сделанных в текущей ветке.
 * `..master` — особенно удобно, когда после сделанной команды `git fetch` хочется посмотреть изменения, произошедшие после последнего `git rebase` или `git merge`.
 * `--since=<date>` — (адресует) ссылается на коммиты, начинающиеся с заданной даты.
 * `--until=<date>` — ссылается на коммиты, сделанные до указанной даты.
 * `--grep=<pattern>` — ссылается на коммиты, сообщение которых подходит под заданное регулярное выражение.
 * `--commiter=<pattern>` — ссылается на коммиты, внесённые человеком, информация о котором совпадает с заданным шаблоном.
 * `--author=<pattern>` — ссылается на все коммиты, сделанные автором, информация о котором совпадает с заданным шаблоном; автор коммита — создатель изменений, которые представляет коммит; для локальной разработки это то же самое, что и коммитер, а если патч присылается по почте, то автор и коммитер обычно отличаются.
 * `--no-merges=<pattern>` — ссылается на коммиты с единственным слиянием, то есть игнирирует все коммиты слияния (merges).

Пример:
```bash
$ git log --grep='foo' --author='johnw' --since="1 month ago" master..
```

```bash
$ mkdir sample; cd sample
```
